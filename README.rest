.. vim: ft=rst sts=2 sw=2 tw=70
.. default-role:: literal

======================================================================
                             studio_napi
======================================================================
----------------------------------------------------------------------
              SUSE Studio API client library for Node.js
----------------------------------------------------------------------

:Author: Roman Neuhauser
:Contact: rneuhauser@suse.cz
:Copyright: This document is in the public domain.

.. This file is marked up using reStructuredText.
   Lines beginning with ".." are reST directives.
   "foo_" or "`foo bar`_" is a link, defined at ".. _foo" or
   ".. _foo bar".
   "::" introduces a literal block (usually some form of code).
   "`foo`" is some kind of identifier.
   Suspicious backslashes in the text ("`std::string`\s") are required
   for reST to recognize the preceding character as syntax.

.. contents::

.. important links:

.. _studio_napi: https://github.com/roman-neuhauser/studio_napi
.. _SUSE Studio: http://susestudio.com/
.. _Node.js: http://nodejs.org/
.. _NPM: http://npmjs.org/
.. _NPM Registry: http://search.npmjs.org/

Overview
========

studio_napi_ is a client library for the `SUSE Studio`_ HTTP API
targetting `Node.js`_.  Two interfaces are exposed, a low-level
and a high-level one.  Both interfaces implement both the admin
and user sides of the API (v2 at the moment).

Status
======

`studio_napi` is in development.  The low-level interface is
implemented to a large extent, the last remaining bits are being
fleshed out; the high-level interface has been designed and we
started the implementation.

POJO Description Language
=========================

Inputs and outputs are described using a would-be object structure
description language.

Common parts of the vocabulary: ::

  Decimal       =o  /^\d+\.\d+/
  Percent       =o  /^\d+%/
  Id            =o  Nonnegative Integer
  Count         =o  Nonnegative Integer
  Seconds       =o  Nonnegative Integer
  IP            =o  (v) ->
    r = v.match /^(\d{1,3})\.(\d{1,3})\.(\d{1,3}).(\d{1,3})$/
    Fail unless r and r[4]
    for b in r[1..]
      Fail if b < 1 or b > 254
  Hostname      =o  /^[a-z]+[-a-z]*[a-z](:?\.[a-z]+[-a-z]*[a-z])*$/
  Host          =o  OneOf IP, Hostname
  Port          =o  OneOf Interval 1, 65536 + 1
  HostPort      =o  "#{Host}:#{Port}"
  Envname       =o  OneOf 'development', 'production', 'testing'
  Hex32         =o  /^[a-f0-9]{32}$/i
  Hex40         =o  /^[a-f0-9]{40}$/i
  Timestamp     =o  /^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\dZ$/
  EmailAddress  =o  /^.+@.+$/
  String        =o  /.*/
  URL           =o  /^https?:\/\/.+$/
  Version       =o  /^\d+\.\d+\.\d+$/
  MBytes        =o  Nonnegative Integer
  LocalPath     =o  /^(?:\/[^/]+)+/
  TrueFalse     =o  OneOf 'true', 'false'
  Username      =o  /^[-\w]+$/
  Groupname     =o  /^[-\w]+$/
  Basename      =o  /^[^/]+$/
  RunLevel      =o  OneOf [1..5]
  OnOff         =o  TypeOf Boolean
  YesNo         =o  TypeOf Boolean
  PackageName   =o  String
  RepositoryName =o String
  SWPatternName =o  String
  LVMGroupName  =o  String
  Locale        =o  String
  BaseSystem    =o  String
  ImageType     =o  OneOf \
    'azure dasd ec2 iso net oem oemiso ovf vhd vmx xen zfcp'.split ' '



Low-level Interface
===================

This is a fairly straightforward async functional interface
using POJOs in place of XML and streams for binary data.

`napilo.session`
++++++++++++++++

`studio_napi/lib/lo` exposes a `session` function which takes
an object specifying the Studio server to connect to, the desired
API side (admin or user), and credentials (see your Studio profile).

**Synopsis** ::

  napilo = require 'studio_napi/lib/lo'

  napilo.session (admin|user):
    url: <url>
    user: <username>
    key: <API key>

`napilo.session` Examples
~~~~~~~~~~~~~~~~~~~~~~~~~

Admin API: ::

  napilo = require 'studio_napi/lib/lo'

  anapi = napilo.session admin:
    url: 'http://susestudio.com/api/v2/admin'
    user: 'rneuhauser'
    key: '69sNafUbAR'

User API: ::

  napilo = require 'studio_napi/lib/lo'

  unapi = napilo.session user:
    url: 'http://susestudio.com/api/v2/user'
    user: 'rneuhauser'
    key: '69sNafUbAR'


`DELETE`, `GET`, `POST`, `PUT`
++++++++++++++++++++++++++++++

To support a slightly more DSLish code, `studio_napi` publishes global
functions corresponding to used HTTP methods; see `unapi, anapi
Examples`_.

**Synopsis** ::

  DELETE = (apimethod[, params], done) ->
  GET    = (apimethod[, params], done) ->
  POST   = (apimethod[, params], done) ->
  PUT    = (apimethod[, params], done) ->


`unapi`, `anapi`
++++++++++++++++

The value returned from `napilo.session` is a function which takes
3 or 4 arguments:

**Synopsis** ::

  anapi = (httpmethod, apimethod[, params], done) ->
  unapi = (httpmethod, apimethod[, params], done) ->

HTTP method
  One of `DELETE`, `GET`, `POST`, `PUT`.
apimethod
  Shortened API method path (without the leading `/api/v2`)
  substrings matching Perl-compatible regular expression /:(\w+)\b/
  are replaced by params[$1].
params
  Optionally, an object of API parameters.  Params not used in
  `apimethod` substitutions comprise the query string.
done: `(error, response) -> ...`
  If `error` is falsy, `reponse` contains a POJO derived from the XML
  response received from Studio server.

`unapi`, `anapi` Examples
~~~~~~~~~~~~~~~~~~~~~~~~~

All examples assume the following code: ::

  assert = require 'assert'
  expect = (require 'chai').expect
  napilo = require 'studio_napi/lib/lo'

  anapi = napilo.session admin:
    url: 'http://susestudio.com/api/v2/admin'
    user: 'rneuhauser'
    key: '69sNafUbAR'

  unapi = napilo.session user:
    url: 'http://susestudio.com/api/v2/user'
    user: 'rneuhauser'
    key: '69sNafUbAR'

A simple GET request: ::

  # GET /api/v2/admin/about

  anapi GET '/about', (e, r) ->

    assert.ifError e, "/about failed: #{e}"

    for p in 'server_name environment git_revision'.split ' '
      (expect r).to.have.property p

URL path substitutions: ::

  # GET /api/v2/user/appliances/42

  unapi GET '/appliances/:app', {app: 42}, (e, r) ->

    assert.ifError e, "/appliances/:app failed: #{e}"

    (expect r).to.have.property 'appliance'

Parameters which are not substituted into `apimethod` form the query
string: ::

  # GET /api/v2/admin/health_check?runner_threshold=75

  anapi GET '/health_check', runner_threshold: 75, (e, r) ->

    assert.ifError e, "/health_check failed: #{e}"

    for p in 'state kiwi_runners testdrive_runners disks'.split ' '
      (expect r).to.have.property p


.. note:: FIXME

  POST form uploads, file uploads, request bodies are neither
  described nor implemented ATM.


`unapi`, `anapi` Endpoints
++++++++++++++++++++++++++

An endpoint is a combination of:
  - HTTP method
  - URL template
  - parameters

`anapi GET /about`
~~~~~~~~~~~~~~~~~~

:Input: default.

:Result:
  ::

    about:
      server_name: HostPort
      environment: Envname
      git_revision: Hex40

`anapi GET /active_users`
~~~~~~~~~~~~~~~~~~~~~~~~~

:Input: default.

:Result:
  ::

    active_users:
      since: Seconds
      users: ArrayOf Id

`anapi GET /health_check`
~~~~~~~~~~~~~~~~~~~~~~~~~

:Input: default.

:Result:
  ::

    Runner =o \
      id: Id
      address: HostPort
      status: OneOf 'auto_disabled', 'disabled', 'pinged', 'registered', 'unreachable'
      last_pinged: Timestamp
      slots: Count
      used_slots: Count
      load: Decimal

    Disk =o \
      path: LocalPath
      used: Percent
      available: Bytes

    ServiceState =o OneOf 'ok', 'error'

    health_check:
      state: ServiceState
      mysql: ServiceState
      thoth: ServiceState
      rmds: ServiceState
      kiwi_runners: ArrayOf Runner
      testdrive_runners: ArrayOf Runner
      disks: ArrayOf Disk

`anapi GET /job_history`
~~~~~~~~~~~~~~~~~~~~~~~~

:Input: default.

:Result:
  ::

    job_history:
      since: Seconds
      builds:
        succeeded: Count
        failed: Count
        successrate: Count
      testdrives: Count

`anapi GET /running_jobs`
~~~~~~~~~~~~~~~~~~~~~~~~~

:Input: default.

:Result:
  ::

    running_jobs:
      builds: ArrayOf Id
      testdrives: ArrayOf Id

`anapi GET /summary`
~~~~~~~~~~~~~~~~~~~~

:Input: default.

:Result:
  ::

    Disk =o \
      filesystem: LocalPath
      total: Bytes
      used: Bytes
      used_percentage: Percent
      available: Bytes
      mount_point: LocalPath

    summary:
      since: Seconds
      last_bug_status_refresh_time: OneOf undefined, Timestamp
      unassigned_failures_count: Count
      builds:
        succeeded: Count
        failed: Count
        errored: Count
        successrate: Count
      testdrives: Count
      active_users: ArrayOf Id
      disks: ArrayOf Disk
      bugs: ArrayOf Id

`unapi GET /account`
~~~~~~~~~~~~~~~~~~~~

:Input: default.

:Result:
  ::

    DiskSize      =o  /^\d+(?:\.\d+)[KMGTPYZ]B$/

    Account =o account:
      username: Username
      displayname: String
      email: EmailAddress
      created_at: Timestamp
      openid_urls: ArrayOf URL
      disk_quota:
        available: DiskSize
        used: Percent

`unapi GET /api_version`
~~~~~~~~~~~~~~~~~~~~~~~~

:Input: default.

:Result:
  ::

    version: /^\d+(?:\.\d+)+$/

`unapi GET /appliances`
~~~~~~~~~~~~~~~~~~~~~~~

:Input: default.

:Result:
  ::

    appliances: ArrayOf Appliance

`unapi GET /appliances/:app`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:Input: default.

:Result:
  ::

    Build =o \
      id: Id
      version: Version
      image_type: ImageType
      image_size: MBytes
      compressed_image_size: MBytes
      download_url: URL

    Appliance =o \
      id: Id
      name: String
      last_edited: Timestamp
      edit_url: URL
      icon_url: URL
      basesystem: BaseSystem
      parent:
        id: Id
        name: String
      builds: ArrayOf Build

    apliance: Appliance

`unapi GET /appliances/:app/configuration`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:Input: default.

:Result:
  ::

    Autostart =o \
      command: String
      description: String
      enabled: TrueFalse
      user: Username

    DbUser =o \
      username: Username
      password: String
      database_list: ListOf String, /,\s*/

    Database =o \
      type: OneOf 'mysql', 'pgsql'
      users: ArrayOf DbUser

    LVMVolume =o \
      size: MBytes
      path: LocalPath

    Script =o \
      enabled: TrueFalse
      script: Text

    User =o \
      name: Username
      password: String
      group: Groupname
      shell: LocalPath
      homedir: LocalPath

    configuration:
      id: Id
      name: String
      description: Text
      website: URL
      tags: ArrayOf Tag
      locale:
        keyboard_layout: String
        language: Locale
        timezone:
          location: Timezone
      network:
        type: OneOf 'dhcp', 'manual'
        hostname: Hostname
        ip: IP
        netmask: IP
        route: IP
        nameservers: ListOf IP, /,\s*/
      firewall:
        enabled: TrueFalse
        open_ports: ArrayOf 'ssh', 'http'
      users: ArrayOf User
      eulas: ArrayOf Text
      databases: ArrayOf Database
      autostarts: ArrayOf Autostart
      settings:
        memory_size: MBytes
        disk_size: GBytes
        swap_size: MBytes
        pae_enabled: TrueFalse
        xen_host_mode_enabled: TrueFalse
        cdrom_enabled: TrueFalse
        webyast_enabled: TrueFalse
        public_clonable: TrueFalse
        runlevel: RunLevel
        automatic_login: Username
      lvm:
        enabled: TrueFalse
        volume_group: LVMGroupName
        volumes: ArrayOf LVMVolume
      scripts:
        build: Script
        boot: Script
        autoyast: Script

`unapi GET /appliances/:app/gpg_keys`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:Input: default.

:Result:
  ::

    GPGKey =o \
      id: Id
      name: String
      target: String
      key: Text

    gpg_keys: ArrayOf GPGKey

`unapi GET /appliances/:app/gpg_key/:key`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:Input: default.

:Result:
  ::

    gpg_key: GPGKey

`unapi GET /appliances/:app/sharing`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:Input: default.

:Result:
  ::

    appliance:
      id: Id
      read_users: ArrayOf Username


`unapi GET /appliances/:app/software`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:Input: default.

:Result:
  ::

    software:
      appliance_id: Id
      patterns: ArrayOf SoftwarePattern
      packages: ArrayOf Package

`unapi GET /appliances/:app/status`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:Input: default.

:Result:
  ::

    Issue =o \
      type: OneOf 'error', ...
      text: String
      solution:
        type: OneOf 'install', ...
        package: PackageName

    status:
      state: OneOf 'error', 'ok'
      issues: ArrayOf Issue

`unapi GET /builds`
~~~~~~~~~~~~~~~~~~~

:Input: default.

:Result:
  ::

    Build =o \
      id: Id
      version: Version
      state: OneOf 'finished', ...
      expired: TrueFalse
      image_type: ImageType
      checksum:
        md5: Hex32
        sha1: Hex40
      size: MBytes
      compressed_image_size: MBytes

    builds: ArrayOf Build

`unapi GET /builds/:bld`
~~~~~~~~~~~~~~~~~~~~~~~~

:Input: default.

:Result:
  ::

    build: Build

`unapi GET /files`
~~~~~~~~~~~~~~~~~~

:Input: default.

:Result:
  ::

    File =o \
      id: Id
      filename: Basename
      path: LocalPath
      owner: Username
      group: Groupname
      permissions: /^[0-7]{3}$/
      enabled: TrueFalse
      download_url: URL

    file: ArrayOf File

`unapi GET /files/:file`
~~~~~~~~~~~~~~~~~~~~~~~~

:Input: default.

:Result:
  ::

    file: File

`unapi GET /repositories`
~~~~~~~~~~~~~~~~~~~~~~~~~

:Input: default.

:Result:
  ::

    Repository =o \
      id: Id
      name: String
      type: OneOf 'rpm-md', ...
      base_system: BaseSystem
      base_url: URL
      matches:
        repository_name: String
        repository_base_url: URL

    repositories: ArrayOf Repository

`unapi GET /repositories/:repo`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:Input: default.

:Result:
  ::

    repository: Repository

`unapi GET /rpms`
~~~~~~~~~~~~~~~~~

:Input: default.

:Result:
  ::

    RPM =o \
      id: Id
      filename: Basename
      size: Bytes
      archive: TrueFalse

    rpms:
      base_system: BaseSystem
      rpms: ArrayOf RPM

`unapi GET /rpms/:rpm`
~~~~~~~~~~~~~~~~~~~~~~

:Input: default.

:Result:
  ::

    rpm:
      id: Id
      filename: Basename
      size: Bytes
      archive: TrueFalse
      base_system: BaseSystem

`unapi GET /running_builds`
~~~~~~~~~~~~~~~~~~~~~~~~~~~

:Input: default.

:Result:
  ::

    RunningBuild =o \
      id: Id
      state: OneOf 'running', ...
      percent: OneOf [0..100]
      time_elapsed: Seconds
      message: String

    running_builds: ArrayOf RunningBuild

`unapi GET /running_builds/:bld`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:Input: default.

:Result:
  ::

    running_build: RunningBuild

`unapi GET /testdrives`
~~~~~~~~~~~~~~~~~~~~~~~

:Input: default.

:Result:
  ::

    TestDrive =o \
      id: Id
      state: OneOf 'running', ...
      build_id: Id

    testdrives: ArrayOf TestDrive

`unapi POST /testdrives`
~~~~~~~~~~~~~~~~~~~~~~~~

:Input: default.

:Result:
  ::

    testdrive:
      id: Id
      state: OneOf 'new', ...
      build_id: Id
      url: URL
      server:
        vnc:
          host: Hostname
          port: Port
          password: String

High-level Interface
====================

`napihi.session`
++++++++++++++++

`studio_napi/lib/hi` exposes a `session` function which takes
an object specifying the Studio server to connect to, the desired
API side (admin or user), and credentials (see your Studio profile)..

**Synopsis** ::

  napihi = require 'studio_napi/lib/hi'

  napihi.session (admin|user):
    url: <url>
    user: <username>
    key: <API key>

`napihi.session` Examples
~~~~~~~~~~~~~~~~~~~~~~~~~

Admin API: ::

  napihi = require 'studio_napi/lib/hi'

  admin = napihi.session admin:
    url: 'http://susestudio.com/api/v2/admin'
    user: 'rneuhauser'
    key: '69sNafUbAR'

User API: ::

  napihi = require 'studio_napi/lib/hi'

  user = napihi.session user:
    url: 'http://susestudio.com/api/v2/user'
    user: 'rneuhauser'
    key: '69sNafUbAR'

`admin`
+++++++

The admin side is a simple object with methods corresponding 1:1
to the low-level admin endpoints:

`admin` Examples
~~~~~~~~~~~~~~~~

::

  napihi = require 'studio_napi/lib/hi'

  admin = napihi.session admin:
    url: 'http://susestudio.com/api/v2/admin'
    user: 'rneuhauser'
    key: '69sNafUbAR'

  admin.about (e, r) ->

    assert.ifError e, "/about failed: #{e}"

    for p in 'server_name environment git_revision'.split ' '
      (expect r).to.have.property p

  admin.health_check, runner_threshold: 75, (e, r) ->

    assert.ifError e, "/health_check failed: #{e}"

    for p in 'state kiwi_runners testdrive_runners disks'.split ' '
      (expect r).to.have.property p


`user`
++++++

`user.create appliance`
~~~~~~~~~~~~~~~~~~~~~~~

:Input:
  ::

    appliance:
      named: String
      based_on: BaseSystem

`app.add package`
~~~~~~~~~~~~~~~~~

:Input:
  ::

    package:
      named: PackageName
      from: RepositoryName
      version: Version

`app.add pattern`
~~~~~~~~~~~~~~~~~

:Input:
  ::

    pattern:
      named: SWPatternName
      from: RepositoryName

`app.add user`
~~~~~~~~~~~~~~

:Input:
  ::

    user:
      named: Username
      id: Id
      member_of: ArrayOf Groupname
      identified_by:
        password: String

`app.configure LVM`
~~~~~~~~~~~~~~~~~~~

:Input:
  ::

    LVM:
      enabled: YesNo
      group: LVMGroupName
      comprising: Map LocalPath, DiskSize

`app.configure PostgreSQL`
~~~~~~~~~~~~~~~~~~~~~~~~~~

:Input:
  ::

    PostgreSQL: ArrayOf DbUser

`app.configure network`
~~~~~~~~~~~~~~~~~~~~~~~

:Input:
  ::

    network:
      hostname: Hostname
      address: IP
      netmask: IP
      gateway: IP
      resolvers: ListOf IP, '/,\s*/


`app.configure RAM`
~~~~~~~~~~~~~~~~~~~

:Input:
  ::

    RAM: DiskSize

`app.configure disk`
~~~~~~~~~~~~~~~~~~~~

:Input:
  ::

    disk: DiskSize

`app.configure swap`
~~~~~~~~~~~~~~~~~~~~

:Input:
  ::

    swap: DiskSize

`app.select locale`
~~~~~~~~~~~~~~~~~~~

:Input:
  ::

    locale:
      language: String
      keyboard: String

`app.select runlevel`
~~~~~~~~~~~~~~~~~~~~~

:Input:
  ::

    runlevel: RunLevel

`app.toggle PostgreSQL`
~~~~~~~~~~~~~~~~~~~~~~~

:Input:
  ::

    PostgreSQL: OnOff

`app.toggle MySQL`
~~~~~~~~~~~~~~~~~~

:Input:
  ::

    MySQL: OnOff

`app.toggle PAE`
~~~~~~~~~~~~~~~~

:Input:
  ::

    PAE: OnOff

`app.toggle Xen_DOM0`
~~~~~~~~~~~~~~~~~~~~~

:Input:
  ::

    Xen_DOM0: OnOff


`user` Examples
~~~~~~~~~~~~~~~~

The user side is an internal DSL.

::

  user = studio.session user:
    url: 'http://susestudio.com/api/v2/user'
    user: 'rneuhauser'
    key: '69sNafUbAR'

  app = user.create appliance:
    named: 'my system'
    based_on: 'SLES11 SP2'

  app.configure LVM:
    enabled: yes
    group: 'mighty-lvm'
    comprising:
      "/var": "800G"
      "/fuvar": "12T"

  app.configure PostgreSQL: [
    { user: 'db_user', password: 'secret', databases: 'foo bar' }
    { user: 'db_admin', password: 'top-secret' }
  ]

  app.toggle PostgreSQL: on
  app.toggle MySQL: off

  app.select runlevel: 3

  app.add package:
    named: 'djbdns'
    from: 'My Repository'
    version: '1.2.3'

  app.add pattern:
    named: 'development'
    from: 'His Repository'

  app.add user:
    named: 'toor'
    id: 1000
    member_of: 'wheel'
    identified_by:
      password: 'secret'

  app.select locale:
    language: 'POSIX'
    keyboard: 'English (US)'

  app.configure network:
    hostname: 'thisbox'
    address: '1.2.3.4'
    netmask: '255.255.0.0'
    gateway: '1.2.1.1'
    resolvers: '1.3.1.53 1.3.2.53'

  app.configure RAM: '1G'
  app.configure disk: '3T'
  app.configure swap: '8G'

  app.toggle PAE: on
  app.toggle Xen_DOM0: off

  app.commit()


Prerequisities
==============

* `Node.js`_ 0.6.x or higher
* NPM_ (any version appropriate for your version of Node.js)
* several packages installable with `npm` (see package.json)


Installation
============

`studio_napi` will appear in the `NPM Registry`_ once it's ready.


Hacking
=======

If you want to hack on `studio_napi`: ::

  git clone https://github.com/roman-neuhauser/studio_napi.git
  cd studio_napi
  npm install
  npm test # or: make check
  # happy hacking

The `npm install` above downloads and installs studio_napi's
dependencies locally (in `./node_modules/`).

